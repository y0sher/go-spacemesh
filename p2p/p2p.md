# P2P Design

## Package - `p2p`

### Description

// *TODO*: Expose these out of the `p2p` package and set `init()` to create a node for that.
// *TODO*: move event loop into `p2p`, create demuxer replacement inside `p2p` (or use demuxer) that routes messages from `net` directly to protocols.

// *DOC-TODO*: Describe the patterns used in `p2p` the event loop, state management and how to prevent deadlocks.
Also about the bootstrap loop and the network loop.

`p2p` package exposes minimal functions as a service to other components in Spacemesh. any part of Spacemesh can
send a p2p message, broadcast or register a protocol to handle incoming messages of a specified type.

It is the root `p2p` communication and it manages all the components used to establish a `p2p` network, send and broadcast messages.


### Public API

- `SendMessage(protocol, payload, nodeID)`

   sends a direct P2P message to a specific nodeID. reports error to callback included in `req`
- `Broadcast(protocol, payload)`

   Disseminates a msg(`req`) to the node's neighbors and starting a gossip protocol

- `Narrowcast()` - *TODO*: Consider narrowcast.

- `RegisterProtocol(Protocol, handler:channel)`

  Register a protocol that should handle incoming messages from this protocol type. (See *Protocols*)

### Under the hood

`p2p` accumulates connections from `net` into a connection pool then routes messages to the respectful protocols.
it does all the heavy lifting when a client wants to send a message or handle a specific protocol.

- `identity.LocalNode` - our `p2p` identity
- `dht` - generate a `dht` for `p2p`, bootstrap it, manage it and issue `Kademlia` operations to lookup nodes.

To initialize `p2p` must create a `dht` and `net`, It must finish a bootstrap before it can allow sending messages or registering protocols,
upon receiving messages from `net` we'll update corresponding node inside our `dht`.

To be able to broadcast messages easily `p2p` holds a connection pool.  

All messages are wrapped to include `Metadata` about the author or sender of the message, signed with the node's `PrivateKey` and sent.

```protobuf
message Metadata {
  string protocol = 1;      // Protocol id string
  bytes reqId = 2;          // Unique request id. Generated by caller. Returned in responses.
  string clientVersion = 3; // Author client version
  int64 timestamp = 4;      // Unix time - authoring time (not sending time)
  bool gossip = 5;          // True to have receiver peer gossip the message to its neighbors
  bytes authPubKey = 6;     // Authoring node Secp256k1 public key (32bytes) - may not be sender
  string authorSign = 7;    // Signature of message data by author + method specific data by message creator node. format: hexEncode([]bytes)
}
```

### Dependencies

   - `crypto` - Generating a key-pair identity and signing/veryfing messages.
   - `log` - for logging purposes.
   - `p2p/net` - to listen on `net` events and use `Connection` to send messages.
   - `p2p/timesync` - time related operations such as checking a message time drift and our own drift against `NTP`
   - `p2p/identity` - to create our own and handle other nodes in the network.
   - `p2p/dht` - all `dht` operations used for looking up peers and saving a quick healthy "goto" peer list.

## package `p2p/identity`

**TODO** : Create the identity package, move in everything related. Take out any responsibility apart from creating the structures.

### Description

Package `identity` implements containers that hold basic information about nodes in the network.
the most basic struct is `BaseNode`

### Public API

- `NewLocalNode(Address string, config nodeconfig, persist bool)` - creates an identity of a local node from scratch.
- `NewLocalNodeFromFile(filepath)` - creates an identity of a local node from file.
- `NewLocalNodeWithKeys(pubKey, privKey)` - creates an identity of a local node with existing keys.
- `NewNodeData(id, ip)` - creates a remote node identity

`LocalNode` includes `BaseNode`.

`BaseNode` implements `Node`

- `Node` - an interface type that represents a basic node contact information

#### `Node`

##### Description

A basic identity node struct that is included in more complicated structs to implement basic identity features.

##### Public API -

- `ID()` - byte array of the node's public key
- `DhtID()` - A `dht.ID` created from the node's ID
- `String()` - An hex-encoded string representation of the node ID. Implements go's `Stringer` interface.
- `Address()` - An IP address (*TODO*: uniform this, some places say `TCPAddress`, some `IP`)

*TODO*: Create a `BaseNode` a basic struct that implements these methods base on a PublicKey and IP address, create an interface `Node` that can be used pass different implementations of identity around.

#### `LocalNode`

##### Description

The `LocalNode` is the struct that represent a our identity in the network. Every `p2p` operation happens with a `LocalNode` identity has its source.
It holds a Private and Public key.
`LocalNode` can initialize from scratch or from existing persistent keys and files. it needs a local address and port.
`PublicKey` is the node's identifier in the network.


##### Public API

- `BaseNode` Methods.
- `PublicKey()` - The node's public key as `crypto.PublicKey` also used as the node's identity in the network.
- `PrivateKey()` - The node's Private Key as `crypto.PrivateKey` used for signing.
- `Save()` - Saves the node's data to the filesystem.
- `Shutdown()` - Shutsdown all node services

* `LocalNode` is loggable meaning you can log messages a `LocalNode` (*DOC-TODO* - Write short doc about `log` in Spacemesh)

        TODO: take these out of today `LocalNode`
        -  `NewProtocolMessageMetadata(proto, reqid, gossip)` - Creates metadata for a message, Should be part of constructing messages

        -  `EnsureNodeDataDirectory()` - Checks that a node directory exists. Should be in `filesystem`

        - `GetRemoteNodeData()` - Returns a remote node data struct from a local node. Should be in `RemoteNodeData`



##### Dependencies

   - `crypto` - used for public and private keys.
   - `filesystem` - Used for persisting the node's info to files
   - `log` - to create a dedicated log for `LocalNode`
   - `dht` - the `dht.ID` methods.


// *DOC-TODO*: describe our process of reading protocol messages metadata for validation without reading the protocol payload


## `p2p/net` Package

### Description

package `p2p/net` is the package that handles all network communications, `net` is a general purpose connection creator and message listener.

 `net` is basically a connection manager. it is used to initiate and to accept all network operations including connections and messages.

  Each connection that established with a `Connection` struct that holds a go `net.Conn` TCP connection that is getting piped through the chosen wire format.

  `net` is wire format agnostic, for now we use binary delimited protobuf messages, we do it using `delimited`
  `delimited` wraps the connections and reads/writes length delimited messages over it.

  
  - `HandshakeProtocol` - Used to initiate a secured connection with peers
  ```protobuf
  // The initiator creates a HandshakeData object
  // with a random IV based on the requested node Public Key
  // and our own Private Key.
  // The request also contains basic details
  // about the initiator to decide if we can can create a session
  message HandshakeData {
      bytes sessionId = 1;    // for req - same as iv. for response - set to req id
      bytes payload = 2; // empty for handshake
      int64 timestamp = 3; // sending time
      string clientVersion = 4; // client version of the sender
      int32 networkID = 5; // network id of sending node
      string protocol = 6; // 'handshake/req' || 'handshake/resp'
      bytes nodePubKey = 7; // 65 bytes uncompressed
      bytes iv = 8; // 16 bytes - AES-256-CBC IV
      bytes pubKey = 9; // 65 bytes (uncompressed) ephemeral public key
      bytes hmac = 10; // HMAC-SHA-256 32 bytes
      string tcpAddress = 11; // ipv4 tcp address and port e.g. x.x.x.x:2424 that the remote node is accepting connections on
      string sign = 12; // hex encoded string 32 bytes sign of all above data by node public key (verifies he has the priv key and he wrote the data
  }
  ```

### Public API

-   `Dial(ip, transport, connectiontype) error` - Initiate a connection with an ip address, returns error or nil
**TODO** : Make dial and listen transport agnostic.
- 	`NewConnections()` - Listen and returns `Connection` over a channel.

-	`GetClosingConnections()` - A channel of connections that are closing because of an error.

#### `Connection`

  ##### Public API -

  - `ID()` - The connection `UUID`
  - `Send(message) error` - Sends a message on the connection, returns an error if failed.
  - `IncomingMessages()` - A channel that listens to messages when a connection starts
  - `Secured() bool` - if this channel is secured.
  **TODO** : return error from sending a message or nil when success.
  - `Close()` - Closes the connection.
  - `RemoteAddr()` - The remote connection address.

  **TODO** : Implement `session` and `handshake` as securedconnection.

  ##### `Connection` dependencies
   - `crypto` - used to create a `UUID` for a connection

  ###  `net` dependencies -
   - `log`
   - `nodeconfig`

#### `p2p/net/delimited`

##### Description

We are using our own simple length-prefix binary format:
```
<32 bits big-endian data-length><message binary data (protobufs-bin-encoded)>
```
We need to use length prefixed protobufs messages because `protobuf`s data doesn't include length and we need this to allow multiple messages on the same tcp/ip connection . see p2p2.conn.go.

##### Public API

  - `ReadFromReader(Reader)` - Pipe a `Reader` through the `delimited` format.
  - `WriteToWriter(Writer)` - Pipe a `Writer` through the `delimited` format.


**TODO** - Decouple `delimited` from `Connection`, write a wire format interface.

## Package `dht`

### Description

`dht` is an integral part of the `p2p` package, it is used to implement the `Kademlia` DHT. A [DHT](https://en.wikipedia.org/wiki/Distributed_hash_table) is mainly used in p2p networks to lookup and probe an ID into an IP address or a file hash to the node it's stored on.

we broke `Kademlia` into 2 parts the node store known as the `RoutingTable` and the protocols, we skip most of `Kademlia` protocol and implement only the `FindNode` protocol which is used to probe node's in the network by IDs.

The `RoutingTable` is a table that holds all the nodes that we know from communications or lookups in the network, it is in charge of keeping that list of nodes healthy and ready for when the node needs to preform a lookup or get information from the network.

For `Kademlia` lookups we're hashing the original nodeIDs to SHA256 hashes. every node ID has its deterministic `dht.ID`.

Using those hashes we calculate and arrange nodes inside the `RoutingTable` according to their "Distance" from us in `Kademlia` "Distance" is determined by a space called the `XOR` Keyspace

#### The `XOR` Keyspace

The `dht.ID`s exist inside the `XOR` keyspace, `dht` also exposes sorting and functionality in this space which should help determine the distance to other nodes in this space.

"Distance" to a node in the XOR space is the result of XORing the IDs of both nodes.
XOR is symmetric and will always produce the same result for the same set of IDs.

When XORing the `dht.ID`s together we use the given result and check the amount of leading zero's in the binary representation of the result.
this is called the `Common Prefix Length` of thses two `dht.ID`s.

The higher the `Common Prefix Length` the closer the node to us.

Example:
```
// For this example and readability we assume the keyspace is 24bits (3 bytes) long instead of 256bits
"123" as dht.ID = a665a4
binary - 10100110110010110100100

"567" as dht.ID = 97a6d2
binary - 100101111010011011010010

XORing : {
"123"(a665a4) XOR "567"(97a6d2) = 31c376
binary - 110001110000111110110
}

The zero prefix length of the xor result
which is the Common Prefix Length : 2
(100101111010011011010010)

A third ID : "789"
"789" as dht.ID = 35a9e3
binary - 1101011010100111100011
XORing "123" with "789" {
  "123"(a665a4) XOR "789"(35a9e3) = 93cc47
  binary - 110001110000111110110
}

The zero prefix length of the xor result
which is the Common Prefix Length : 0

567 is closer in xor space to 123 than 789

```

### `DHT`

#### Public API

  - `New` - creates a new `DHT`


  - `DHT.Bootstrap(nodes)` - bootstrap the routing table using the given nodes
  - `DHT.Update(node)` - Update a node in the routing table
  if we know this peer we move it to the top of the `Bucket`
   If we never heard of this peer, we insert it to the appropriate bucket, if this bucket is full then we ping the last contacted peer (which should be the last in the bucket) and see if its alive. we then compare latency metrics and choose the best of the two.
  - `DHT.FindNode(id)` - Issue a `Kademlia` find node operation in the network

`dht` implements `RoutingTable` which is a table that holds all the nodes that we know from communications or lookups in the network.

The `RoutingTable` is in charge of keeping that list of nodes healthy and ready for when the node needs to preform a lookup or get information from the network.

The nodes in the `RoutingTable` are arranged inside `Bucket`s in `Kademlia` they are called `KBuckets`. every bucket represent a `Common Prefix Length` we store 20 `Buckets` which hold nodes according to our `BucketSize` parameter which is currently 20.
The higher the `Bucket` number, the closer the nodes in the list to us.
Most of the nodes are going to be in `Bucket` 0, half of the network according to `Kademlia`, half of the rest of the nodes will be in `Bucket` 1, and so forth.
this is why we hold only 20 buckets.

#### Dependencies

 -  `net` - issue operations through a secure/unsecured connections

 *TODO*: Move bootstrapping inside `dht`
 *TODO*: Implment lower level ping to check that nodes are alive inside the routing table (Maybe in `net`?)
 *TODO* : Move all FindNode protocol issueing inside `dht`

##### Bootstrapping

The bootstrap process is what lets us join the p2p network.

When the Spacemesh node start it has to fill it's `RoutingTable` with fresh and active nodes, to do this process the node is equipped with a list of Bootstrap Nodes. every Spacemesh node can act as Bootstrap Node so they can be replaced with a detailed acquired from any other source.

To bootstrapping process is just a matter of issuing the `FindNode` `Kademlia` protocol (refer to `P2P Protocols`) with the node own `dht.ID` as a parameter. this will return a list of nodes close to our own `dht.ID`, we'll query those
nodes (Concurrently) for the same ID until we don't get new results and we queried all nodes.

This will make every node that see our request to update its `RoutingTable` with our node's `dht.ID` and also fill our `dht.ID` with these nodes.


## `timesync` package

`timesync` is a package that handles all time synchronization of the node. it is used to check that the node is sync against multiple [`NTP`](https://en.wikipedia.org/wiki/Network_Time_Protocol) servers.
if our node is too much out of sync it won't start and request to calibrate the OS clock against `NTP`.
Whenever we receive a message we use `timesync` to check if its not too much back or forth in time to accept. this limit is determined by a configurable value (*TODO*: make it configurable) in the node `MaxAllowedMessageDrift`.


## `nodeconfig`

### Description

`nodeconfig` loads config parameters from the default config file, parameters inside `nodeconfig` are related to `p2p`.

### Public API

 - `DefaultConfig()` - A default config for the node
